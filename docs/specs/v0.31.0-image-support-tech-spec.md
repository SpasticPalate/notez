# v0.31.0 Technical Specification: Image Support

## Overview

Add inline image support to notes, allowing users to paste, drag-drop, or upload images directly into the editor. Images will be stored in MinIO (S3-compatible object storage) and rendered inline within notes.

## Goals

1. **Seamless Image Insertion**: Paste from clipboard, drag-drop, or click to upload
2. **Efficient Storage**: MinIO for scalable, self-hosted object storage
3. **Optimized Delivery**: Automatic image compression and resizing
4. **Clean UX**: Inline rendering with loading states and error handling

## Architecture

### Storage Layer: MinIO

MinIO provides S3-compatible object storage that's:
- Self-hosted (aligns with Notez philosophy)
- Docker-native (easy to add to compose stack)
- S3-compatible (standard API, easy migration path)
- Efficient (handles large files without database bloat)

### Data Flow

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Browser   │────▶│   Backend   │────▶│    MinIO    │
│  (TipTap)   │     │  (Fastify)  │     │  (Storage)  │
└─────────────┘     └─────────────┘     └─────────────┘
      │                    │                    │
      │  1. Upload image   │                    │
      │───────────────────▶│                    │
      │                    │  2. Store file     │
      │                    │───────────────────▶│
      │                    │                    │
      │                    │  3. Return URL     │
      │                    │◀───────────────────│
      │  4. Insert URL     │                    │
      │◀───────────────────│                    │
      │                    │                    │
      │  5. Render image   │                    │
      │───────────────────▶│  6. Serve image   │
      │                    │◀──────────────────▶│
└─────────────────────────────────────────────────────┘
```

## Implementation Stories

### Story 1: Docker Infrastructure (MinIO)

**Priority**: P0 (Blocking)
**Estimate**: Small

#### Tasks

1. Add MinIO service to `compose.yml` and `compose.prod.yml`:
   ```yaml
   minio:
     image: minio/minio:latest
     command: server /data --console-address ":9001"
     environment:
       MINIO_ROOT_USER: ${MINIO_ROOT_USER:-notez}
       MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD:-notez-secret-key}
     volumes:
       - minio_data:/data
     ports:
       - "9000:9000"   # API
       - "9001:9001"   # Console (dev only)
     healthcheck:
       test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
       interval: 30s
       timeout: 20s
       retries: 3
   ```

2. Add volume declaration:
   ```yaml
   volumes:
     postgres_data:
     minio_data:
   ```

3. Update `.env.example`:
   ```env
   # MinIO Storage
   MINIO_ENDPOINT=minio
   MINIO_PORT=9000
   MINIO_USE_SSL=false
   MINIO_ACCESS_KEY=notez
   MINIO_SECRET_KEY=notez-secret-key
   MINIO_BUCKET=notez-images
   ```

4. Backend should wait for MinIO to be healthy before starting

#### Acceptance Criteria
- [ ] MinIO container starts with docker-compose
- [ ] Data persists across container restarts
- [ ] Console accessible at localhost:9001 in dev
- [ ] Health check passes

---

### Story 2: Backend Image Upload Endpoint

**Priority**: P0 (Blocking)
**Estimate**: Medium

#### Tasks

1. **Install dependencies**:
   ```bash
   npm install @fastify/multipart minio sharp uuid
   npm install -D @types/uuid
   ```

2. **Create storage service** (`backend/src/services/storage.service.ts`):
   ```typescript
   import { Client } from 'minio';
   import sharp from 'sharp';
   import { v4 as uuidv4 } from 'uuid';

   export class StorageService {
     private client: Client;
     private bucket: string;

     constructor() {
       this.client = new Client({
         endPoint: process.env.MINIO_ENDPOINT || 'localhost',
         port: parseInt(process.env.MINIO_PORT || '9000'),
         useSSL: process.env.MINIO_USE_SSL === 'true',
         accessKey: process.env.MINIO_ACCESS_KEY || 'notez',
         secretKey: process.env.MINIO_SECRET_KEY || 'notez-secret-key',
       });
       this.bucket = process.env.MINIO_BUCKET || 'notez-images';
     }

     async initialize(): Promise<void> {
       const exists = await this.client.bucketExists(this.bucket);
       if (!exists) {
         await this.client.makeBucket(this.bucket);
         // Set bucket policy for public read access
         const policy = {
           Version: '2012-10-17',
           Statement: [{
             Effect: 'Allow',
             Principal: { AWS: ['*'] },
             Action: ['s3:GetObject'],
             Resource: [`arn:aws:s3:::${this.bucket}/*`],
           }],
         };
         await this.client.setBucketPolicy(this.bucket, JSON.stringify(policy));
       }
     }

     async uploadImage(
       buffer: Buffer,
       mimeType: string,
       userId: string
     ): Promise<{ id: string; url: string }> {
       // Process image with sharp
       const processed = await sharp(buffer)
         .resize(1920, 1920, { fit: 'inside', withoutEnlargement: true })
         .jpeg({ quality: 85 })
         .toBuffer();

       const id = uuidv4();
       const key = `${userId}/${id}.jpg`;

       await this.client.putObject(this.bucket, key, processed, {
         'Content-Type': 'image/jpeg',
       });

       const url = `/api/images/${id}`;
       return { id, url };
     }

     async getImage(id: string, userId: string): Promise<Buffer | null> {
       const key = `${userId}/${id}.jpg`;
       try {
         const stream = await this.client.getObject(this.bucket, key);
         const chunks: Buffer[] = [];
         for await (const chunk of stream) {
           chunks.push(chunk);
         }
         return Buffer.concat(chunks);
       } catch {
         return null;
       }
     }

     async deleteImage(id: string, userId: string): Promise<void> {
       const key = `${userId}/${id}.jpg`;
       await this.client.removeObject(this.bucket, key);
     }
   }
   ```

3. **Create image routes** (`backend/src/routes/images.routes.ts`):
   ```typescript
   import { FastifyInstance } from 'fastify';
   import { storageService } from '../services/storage.service';

   export async function imageRoutes(fastify: FastifyInstance) {
     // Upload image
     fastify.post('/upload', {
       preHandler: [fastify.authenticate],
       handler: async (request, reply) => {
         const data = await request.file();
         if (!data) {
           return reply.status(400).send({ error: 'No file uploaded' });
         }

         const allowedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
         if (!allowedTypes.includes(data.mimetype)) {
           return reply.status(400).send({ error: 'Invalid file type' });
         }

         const buffer = await data.toBuffer();
         const maxSize = 10 * 1024 * 1024; // 10MB
         if (buffer.length > maxSize) {
           return reply.status(400).send({ error: 'File too large (max 10MB)' });
         }

         const result = await storageService.uploadImage(
           buffer,
           data.mimetype,
           request.user.id
         );

         return { success: true, ...result };
       },
     });

     // Get image
     fastify.get('/:id', async (request, reply) => {
       const { id } = request.params as { id: string };
       // Note: For public images, we may need to look up the userId from a database
       // For now, we'll need the Image model to track ownership

       const image = await prisma.image.findUnique({ where: { id } });
       if (!image) {
         return reply.status(404).send({ error: 'Image not found' });
       }

       const buffer = await storageService.getImage(id, image.userId);
       if (!buffer) {
         return reply.status(404).send({ error: 'Image not found' });
       }

       reply.header('Content-Type', 'image/jpeg');
       reply.header('Cache-Control', 'public, max-age=31536000');
       return reply.send(buffer);
     });
   }
   ```

4. **Register multipart plugin** in `backend/src/index.ts`:
   ```typescript
   import multipart from '@fastify/multipart';

   fastify.register(multipart, {
     limits: {
       fileSize: 10 * 1024 * 1024, // 10MB
     },
   });
   ```

5. **Add validation schema** (`backend/src/utils/validation.schemas.ts`):
   ```typescript
   export const uploadImageSchema = z.object({
     // Multipart file validation handled by fastify-multipart
   });
   ```

#### Acceptance Criteria
- [ ] POST `/api/images/upload` accepts multipart form data
- [ ] Images are processed (resized, compressed) before storage
- [ ] GET `/api/images/:id` returns the image with proper headers
- [ ] File size limit enforced (10MB)
- [ ] Only allowed MIME types accepted
- [ ] Images stored with user isolation (userId prefix)

---

### Story 3: Database Image Model

**Priority**: P0 (Blocking)
**Estimate**: Small

#### Tasks

1. **Add Prisma model** (`backend/prisma/schema.prisma`):
   ```prisma
   model Image {
     id        String   @id @default(uuid())
     userId    String
     noteId    String?
     filename  String
     mimeType  String
     size      Int
     width     Int?
     height    Int?
     createdAt DateTime @default(now())

     user User  @relation(fields: [userId], references: [id], onDelete: Cascade)
     note Note? @relation(fields: [noteId], references: [id], onDelete: SetNull)

     @@index([userId])
     @@index([noteId])
   }
   ```

2. **Update Note model** to include images relation:
   ```prisma
   model Note {
     // ... existing fields
     images Image[]
   }
   ```

3. **Update User model** to include images relation:
   ```prisma
   model User {
     // ... existing fields
     images Image[]
   }
   ```

4. **Create and run migration**:
   ```bash
   npx prisma migrate dev --name add_image_model
   ```

#### Acceptance Criteria
- [ ] Image model created with proper relations
- [ ] Migration runs successfully
- [ ] Foreign keys properly set up with cascade rules

---

### Story 4: TipTap Image Extension

**Priority**: P0 (Blocking)
**Estimate**: Medium

#### Tasks

1. **Install TipTap image extension**:
   ```bash
   npm install @tiptap/extension-image
   ```

2. **Create custom image extension** with upload handling (`frontend/src/components/TiptapImageExtension.ts`):
   ```typescript
   import Image from '@tiptap/extension-image';
   import { Plugin, PluginKey } from '@tiptap/pm/state';

   export interface ImageUploadOptions {
     onUpload: (file: File) => Promise<string>;
   }

   export const ImageUploadExtension = Image.extend<ImageUploadOptions>({
     addOptions() {
       return {
         ...this.parent?.(),
         onUpload: async () => '',
       };
     },

     addProseMirrorPlugins() {
       const { onUpload } = this.options;

       return [
         new Plugin({
           key: new PluginKey('imageUpload'),
           props: {
             handlePaste: (view, event) => {
               const items = event.clipboardData?.items;
               if (!items) return false;

               for (const item of items) {
                 if (item.type.startsWith('image/')) {
                   event.preventDefault();
                   const file = item.getAsFile();
                   if (file) {
                     onUpload(file).then((url) => {
                       if (url) {
                         const { tr } = view.state;
                         const node = view.state.schema.nodes.image.create({ src: url });
                         view.dispatch(tr.replaceSelectionWith(node));
                       }
                     });
                   }
                   return true;
                 }
               }
               return false;
             },

             handleDrop: (view, event) => {
               const files = event.dataTransfer?.files;
               if (!files || files.length === 0) return false;

               const file = files[0];
               if (!file.type.startsWith('image/')) return false;

               event.preventDefault();

               const coordinates = view.posAtCoords({
                 left: event.clientX,
                 top: event.clientY,
               });

               onUpload(file).then((url) => {
                 if (url && coordinates) {
                   const { tr } = view.state;
                   const node = view.state.schema.nodes.image.create({ src: url });
                   view.dispatch(tr.insert(coordinates.pos, node));
                 }
               });

               return true;
             },
           },
         }),
       ];
     },
   });
   ```

3. **Update TiptapEditor.tsx** to include image extension:
   ```typescript
   import { ImageUploadExtension } from './TiptapImageExtension';
   import { uploadImage } from '../api/images';

   // In useEditor config:
   ImageUploadExtension.configure({
     onUpload: async (file: File) => {
       try {
         const result = await uploadImage(file);
         return result.url;
       } catch (error) {
         console.error('Failed to upload image:', error);
         toast.error('Failed to upload image');
         return '';
       }
     },
   }),
   ```

4. **Add image styles** to editor CSS:
   ```css
   .ProseMirror img {
     max-width: 100%;
     height: auto;
     border-radius: 8px;
     margin: 1rem 0;
   }

   .ProseMirror img.ProseMirror-selectednode {
     outline: 3px solid #3b82f6;
     outline-offset: 2px;
   }
   ```

#### Acceptance Criteria
- [ ] Images can be pasted from clipboard
- [ ] Images can be dragged and dropped
- [ ] Images render inline in the editor
- [ ] Selected images show visual indicator
- [ ] Loading state shown during upload

---

### Story 5: Frontend API Client

**Priority**: P0 (Blocking)
**Estimate**: Small

#### Tasks

1. **Create image API client** (`frontend/src/api/images.ts`):
   ```typescript
   import { apiClient } from './client';

   export interface UploadResult {
     success: boolean;
     id: string;
     url: string;
   }

   export async function uploadImage(file: File): Promise<UploadResult> {
     const formData = new FormData();
     formData.append('file', file);

     const response = await fetch('/api/images/upload', {
       method: 'POST',
       headers: {
         'Authorization': `Bearer ${localStorage.getItem('token')}`,
       },
       body: formData,
     });

     if (!response.ok) {
       const error = await response.json();
       throw new Error(error.error || 'Upload failed');
     }

     return response.json();
   }
   ```

#### Acceptance Criteria
- [ ] Upload function handles FormData correctly
- [ ] Auth token included in request
- [ ] Error responses properly handled

---

### Story 6: Image Upload Button (Optional Enhancement)

**Priority**: P1 (Nice to have)
**Estimate**: Small

#### Tasks

1. Add image upload button to editor toolbar
2. Create file input with hidden trigger
3. Handle file selection and upload

#### Acceptance Criteria
- [ ] Toolbar shows image upload button
- [ ] Clicking opens file picker
- [ ] Selected image uploads and inserts

---

## Testing Plan

### Manual Testing Checklist

1. **Paste from clipboard**
   - [ ] Screenshot paste (Windows: Win+Shift+S)
   - [ ] Copy image from browser, paste
   - [ ] Copy image from file explorer, paste

2. **Drag and drop**
   - [ ] Drag image file from desktop
   - [ ] Drag image from browser
   - [ ] Drag multiple images (should handle first only)

3. **File types**
   - [ ] JPEG uploads correctly
   - [ ] PNG uploads correctly
   - [ ] WebP uploads correctly
   - [ ] GIF uploads correctly (converted to JPEG)
   - [ ] Non-image files rejected

4. **Edge cases**
   - [ ] Large image (>10MB) rejected with error
   - [ ] Upload while offline shows error
   - [ ] Corrupted image file handled gracefully

5. **Rendering**
   - [ ] Images display in editor
   - [ ] Images display in note preview
   - [ ] Images persist after save/reload
   - [ ] Images work in dark mode

---

## Security Considerations

1. **File validation**: Verify MIME type server-side, not just extension
2. **Size limits**: Enforce 10MB limit at both frontend and backend
3. **User isolation**: Store images in user-specific paths
4. **Authentication**: Require auth for upload, consider auth for view
5. **Content-Type**: Set proper headers to prevent XSS

---

## Future Enhancements (Out of Scope)

- Image gallery/browser
- Image editing (crop, resize)
- Image search/OCR
- Thumbnail generation
- CDN integration
- Image compression settings

---

## Dependencies

### Backend
- `@fastify/multipart` - File upload handling
- `minio` - S3-compatible storage client
- `sharp` - Image processing
- `uuid` - Unique ID generation

### Frontend
- `@tiptap/extension-image` - TipTap image support

### Infrastructure
- MinIO container in docker-compose

---

## Rollout Plan

1. Create feature branch `feature/v0.31.0-image-support`
2. Implement stories in order (1 → 2 → 3 → 4 → 5)
3. Test locally with docker-compose
4. Create PR for review
5. Merge to main
6. Tag v0.31.0 release
7. Deploy via Portainer

---

## Changelog Entry

```markdown
## [0.31.0] - 2024-12-XX

### Added
- **Image Support**: Paste, drag-drop, or upload images directly into notes
- MinIO storage integration for scalable image hosting
- Automatic image optimization (resize, compress)
- Inline image rendering in editor

### Changed
- Docker compose now includes MinIO service

### Technical
- Added `@tiptap/extension-image` for editor support
- Added `@fastify/multipart` for file uploads
- New Image model in database schema
```
